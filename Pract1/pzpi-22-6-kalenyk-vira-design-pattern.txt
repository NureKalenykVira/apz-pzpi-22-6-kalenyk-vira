МІНІСТЕРСТВО ОСВІТИ I НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



Кафедра програмної інженерії





ЗВІТ
до практичної роботи № 1
з дисципліни «Архітектура програмного забезпечення»
на тему «Шаблон (патерн) проектування ПЗ - Спостерігач»





Виконала:                                                     			Перевірив:
ст. гр. ПЗПІ-22-6,                                           	 	ст. викл. каф. ПІ,
Каленик Віра Олександрівна					Сокорчук Ігор Петрович






Харків 2025
1 ШАБЛОН (ПАТЕРН) ПРОЕКТУВАННЯ ПЗ
1.1	Історія змін
№	Дата	Версія звіту	Опис змін та виправлень
1	06.04.2025	0.1	Оформлено титульну сторінку, створено розділ «Завдання»
2	07.04.2025	0.2	Створено розділ «Опис виконаної роботи», додатки Б та В, написано розділ «Висновки»
3	07.04.2025	0.3	Додано додаток А, виправлено оформлення (додано колонтитули, налаштовано міжрядкові інтервали, тощо)

1.2	Завдання
Завдання на практичне заняття 1:
1.	Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ» (із книг: Ґамма, “ООП. Патерни проєктування”, GoF, крім патерна Singletone);
2.	Створити та оформити слайди презентації доповіді;
3.	Створити та опублікувати на YouTube відеозапис доповіді;
4.	Оформити та завантажити на dl.nure.ua звіт до виконаної роботи;
5.	При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua;
6.	Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main;
7.	Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань;
8.	Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub;
9.	Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1.

1.3	Опис виконаної роботи
1.	Було обрано шаблон (патерн) «Спостерігач» (Observer) для аналізу. 
2.	Було досліджено структуру шаблону та описано його учасників: Subject, Observer, ConcreteSubject і ConcreteObserver.
3.	Було сформульовано мету застосування шаблону та обґрунтовано доцільність його використання у випадках, коли об’єкти мають бути автоматично повідомлені про зміну стану іншого об’єкта.
4.	Було побудовано графічну діаграму структури шаблону Observer із позначенням основних взаємозв’язків між компонентами (див. рисунок Б.2).
5.	Було реалізовано базову структуру шаблону мовою програмування C++ із використанням віртуального інтерфейсу Observer, списку підписників у Subject та механізму сповіщення (повний код подано в додатку В.1).
6.	Було розроблено кілька прикладів практичного застосування шаблону Observer, зокрема в інтерфейсах користувача, архітектурі MVC, системах новин, редакторах та фінансових застосунках (див. додаток В.2 – В.6).
7.	Було визначено переваги та недоліки використання шаблону Observer, зокрема гнучкість, розширюваність і можливість слабкого зв’язку між компонентами, а також потенційні проблеми, пов’язані з надмірним сповіщенням або рекурсією.
8.	Було проаналізовано споріднені шаблони проєктування, зокрема Mediator та Singleton, які часто застосовуються спільно з Observer для побудови складних реактивних систем.
9.	Було підготовлено презентацію за темою роботи, яка містить теоретичну частину, схеми, узагальнення прикладів та висновки (див. додаток Б).

1.4	Висновки
У результаті виконання індивідуального завдання було поглиблено знання щодо структури та особливостей шаблонів проєктування, зокрема патерна «Спостерігач». Було опрацьовано методику побудови шаблону, а також вивчено принципи слабкого зв’язування між компонентами системи. У процесі роботи було набутого досвіду реалізації шаблону Observer мовою C++ з використанням абстрактних інтерфейсів, механізмів підписки та розсилання повідомлень. Було сформовано навички застосування шаблонів у різних прикладних контекстах. Результати роботи оформлено у вигляді структурованої презентації, доповіді та прикладів програмного коду, що відповідає вимогам до виконання практичної частини. Одержані знання можуть бути застосовані в подальшій розробці програмного забезпечення з підтримкою реактивної поведінки об’єктів.

ДОДАТОК А
Посилання на відеозапис доповіді та текст хронологічного опису доповіді
	Відеозапис доповіді на YouTube: https://youtu.be/D4b0pbJkKoc.
  Хронологічний опис доповіді: 
1.	00:00 - Привітання; 
2.	00:13 - Зміст презентації/доповіді; 
3.	00:32 - Вступ; 
4.	01:23 - Призначення шаблону; 
5.	02:11 - Мотивація використання (проблема); 
6.	03:44 - Умови доцільності застосування; 
7.	04:55 - Структура шаблону; 
8.	07:40 - Переваги та недоліки; 
9.	10:08 - Реалізація шаблону на С++ ; 
10.	11:33 - Застосування Observer у графічних інтерфейсах (GUI); 
11.	13:16 - Застосування Observer у моделі Model–View–Controller (MVC); 
12.	14:06 - Застосування Observer у системі підписки/новин; 
13.	14:52 - Застосування Observer у графічних редакторах; 
14.	15:39 - Застосування Observer у фінансових системах; 
15.	16:10 - Споріднені паттерни; 
16.	18:08 - Висновки; 
17.	19:22 - Список використаних джерел; 
18.	19:31 - Завершення.

	
 
ДОДАТОК Б
Слайди презентації доповіді
 
Рисунок Б.1 – Титульний слайд
 
Рисунок Б.2 – Зміст презентації
 
Рисунок Б.3 – Вступ
 
Рисунок Б.4 – Призначення шаблону
 
Рисунок Б.5 – Мотивація до використання шаблону
 
Рисунок Б.6 – Умови доцільності застосування шаблону
 
Рисунок Б.7 – Структура шаблону Observer
 
Рисунок Б.8 – Основні переваги та недоліки шаблону
 
Рисунок Б.9 – Реалізація шаблону Observer мовою C++
 
Рисунок Б.10 – Застосування Observer у графічних інтерфейсах (GUI)
 
Рисунок Б.11 – Застосування Observer у моделі Model–View–Controller (MVC)
 
Рисунок Б.12 – Застосування Observer у системі підписки/новин
 
Рисунок Б.13 – Застосування Observer у графічних редакторах
 
Рисунок Б.14 – Застосування Observer у фінансових системах
 
Рисунок Б.15 – Споріднені шаблони
 
Рисунок Б.16 – Висновки
 
Рисунок Б.17 – Список використаних джерел
 
Рисунок Б.18 – Завершальний слайд
 
ДОДАТОК В
Приклади програмного коду
1.	// Реалізація шаблону Observer 
2.	class Observer {
3.	public:
4.	    virtual void Update(int newState) = 0;
5.	    virtual ~Observer() = default;
6.	};
7.	
8.	class Subject {
9.	protected:
10.	    std::vector<Observer*> observers;
11.	public:
12.	    void Attach(Observer* o) {
13.	        observers.push_back(o);
14.	    }
15.	
16.	    void Detach(Observer* o) {
17.	        observers.erase(std::remove(observers.begin(), observers.end(), o), observers.end());
18.	    }
19.	
20.	    void Notify(int state) {
21.	        for (Observer* o : observers) {
22.	            o->Update(state);
23.	        }
24.	    }
25.	};
26.	
27.	class ConcreteSubject : public Subject {
28.	private:
29.	    int state;
30.	public:
31.	    void SetState(int s) {
32.	        state = s;
33.	        Notify(state);
34.	    }
35.	};
36.	
37.	class ConcreteObserver : public Observer {
38.	private:
39.	    std::string name;
40.	    int observerState;
41.	public:
42.	    ConcreteObserver(std::string n) : name(n), observerState(0) {}
43.	
44.	    void Update(int newState) override {
45.	        observerState = newState;
46.	        std::cout << "Спостерігач [" << name << "]: стан = " << observerState << "\n";
47.	    }
48.	};
49.	
50.	// Застосування Observer у графічних інтерфейсах (GUI)
51.	class DataModel : public Subject {
52.	private:
53.	    std::string value;
54.	public:
55.	    void SetValue(const std::string& v) {
56.	        value = v;
57.	        Notify(0);
58.	    }
59.	    std::string GetValue() const { return value; }
60.	};
61.	
62.	class TextLabel : public Observer {
63.	private:
64.	    DataModel* model;
65.	public:
66.	    explicit TextLabel(DataModel* m) : model(m) {}
67.	    void Update(int) override {
68.	        std::cout << "TextLabel: поточне значення моделі — "
69.	            << model->GetValue() << std::endl;
70.	    }
71.	};
72.	
73.	// Застосування Observer у моделі Model–View–Controller (MVC)
74.	class TemperatureModel : public Subject {
75.	private:
76.	    float temperature;
77.	public:
78.	    void SetTemperature(float t) {
79.	        temperature = t;
80.	        Notify(0);
81.	    }
82.	    float GetTemperature() const { return temperature; }
83.	};
84.	
85.	class ThermometerView : public Observer {
86.	private:
87.	    TemperatureModel* model;
88.	public:
89.	    explicit ThermometerView(TemperatureModel* m) : model(m) {}
90.	    void Update(int) override {
91.	        std::cout << "ThermometerView: температура = "
92.	            << model->GetTemperature() << "°C\n";
93.	    }
94.	};
95.	
96.	// Застосування Observer у системі підписки/новин
97.	enum class NewsTopic { Politics, Technology };
98.	
99.	class NewsReader : public Observer {
100.	private:
101.	    std::string name;
102.	public:
103.	    explicit NewsReader(std::string n) : name(n) {}
104.	    void Update(int topic) override {
105.	        std::cout << "Читач [" << name << "] отримав новину: ";
106.	        if (topic == static_cast<int>(NewsTopic::Politics))
107.	            std::cout << "Політика\n";
108.	        else if (topic == static_cast<int>(NewsTopic::Technology))
109.	            std::cout << "Технології\n";
110.	    }
111.	};
112.	
113.	// Застосування Observer у графічних редакторах
114.	class Canvas : public Subject {
115.	private:
116.	    int objectCount = 0;
117.	public:
118.	    void AddObject() {
119.	        ++objectCount;
120.	        Notify(objectCount);
121.	    }
122.	};
123.	
124.	class LayerPanel : public Observer {
125.	public:
126.	    void Update(int count) override {
127.	        std::cout << "LayerPanel: кількість об’єктів на полотні — "
128.	            << count << std::endl;
129.	    }
130.	};
131.	
132.	// Застосування Observer у фінансових системах
133.	class Stock : public Subject {
134.	private:
135.	    double price;
136.	public:
137.	    void SetPrice(double p) {
138.	        price = p;
139.	        Notify(static_cast<int>(price));
140.	    }
141.	};
142.	
143.	class StockChart : public Observer {
144.	public:
145.	    void Update(int price) override {
146.	        std::cout << "StockChart: нова ціна акцій — $"
147.	            << price << std::endl;
148.	    }
149.	};

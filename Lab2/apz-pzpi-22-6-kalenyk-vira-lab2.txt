МІНІСТЕРСТВО ОСВІТИ I НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



Кафедра програмної інженерії




ЗВІТ
до лабораторної роботи № 2
з дисципліни «Архітектура програмного забезпечення»
на тему «Розробка програмної архітектури, створенння та відлагодження
 програмного коду серверної частини програмної системи»




Виконала:                                                     			Перевірив:
ст. гр. ПЗПІ-22-6,                                           	 	ст. викл. каф. ПІ,
Каленик Віра Олександрівна					Сокорчук Ігор Петрович







Харків 2025

1 ІСТОРІЯ ЗМІН
№	Дата	Версія звіту	Опис змін та виправлень
1	10.05.2025	0.1	Оформлено титульну сторінку, створено структуру звіту, додано розділ «Завдання» та початковий опис архітектури системи.
2	11.05.2025	0.2	Створено опис архітектури серверної частини, розроблено специфікацію REST API, UML-діаграми: Deployment Diagram, Use Case Diagram, ER Diagram та Component Diagram. Додано специфікацію маршрутів REST API.
3	12.05.2025	0.3	Проведено тестування CRUD-операцій, розроблено розділ «Висновки», оновлено специфікацію REST API, додано додатки з фрагментами коду.

2 ЗАВДАННЯ
Завдання до лабораторної 2:
1.	Розробити серверну частину програмної системи, що включає CRUD-операції для основних сутностей (Users, Refrigerators, Products, Sensors, Notifications, Zones), інтеграцію з базою даних MySQL та забезпечення зв'язку між компонентами через REST API.
2.	Реалізувати механізм обробки даних з IoT-сенсорів: збір даних про температуру, вологість та ідентифікацію продуктів через RFID, збереження показників у базі даних, генерацію сповіщень при досягненні критичних параметрів.
3.	Розробити механізм управління користувачами: реєстрація, авторизація (з використанням JWT-токенів), оновлення даних та видалення користувачів, управління ролями користувачів (Admin, Regular User).
4.	Реалізувати модуль аналітики та генерації звітів: формування звітів про стан продуктів, умови їх зберігання та ефективність використання, відображення аналітичних даних на веб- та мобільних платформах.
5.	Забезпечити підтримку багаторівневого адміністрування: управління конфігураціями системи, можливість резервного копіювання даних та відновлення системи, доступ до сенсорів та контролю зон холодильника.
6.	Розробити UML-діаграми для опису архітектури: Deployment Diagram для відображення фізичної структури розгортання серверної частини, Use Case Diagram для опису прецедентів використання, ER Diagram для моделювання структури бази даних, Component Diagram для опису основних компонентів серверної частини.
7.	Реалізувати функціональне тестування: перевірити коректність CRUD-операцій, тестування роботи сенсорів та відправки даних на сервер, тестування відправки сповіщень та генерації звітів, провести перевірку ролей користувачів та захисту даних.
8.	Створити та опублікувати на YouTube відеозапис тестування з демонстрацією основного функціоналу серверної частини та поясненням процесу тестування та інженерних рішень.
9.	Оформити звіт за результатами лабораторної роботи, додавши розділи: аналіз завдання, опис архітектури, специфікація REST API, діаграми UML, опис математичних методів обробки даних, текстовий опис програмної реалізації та висновки щодо виконаної роботи.
10.	Завантажити звіт у форматі PDF на платформу dl.nure.ua та додати посилання на YouTube-відео в коментарях до роботи.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 ОПИС АРХІТЕКТУРИ СИСТЕМИ
Архітектура програмної системи побудована за клієнт-серверною моделлю. Основна ідея клієнт-серверної архітектури полягає у розподілі завдань між двома компонентами: клієнтом і сервером. Клієнт відповідає за взаємодію з користувачем, збір та відображення інформації, тоді як сервер займається обробкою бізнес-логіки, зберіганням і маніпуляцією даними. Така архітектура спрощує управління даними, підвищує безпеку доступу та забезпечує масштабованість системи. Саме ці властивості стали визначальними для вибору клієнт-серверної архітектури для програмної системи. Відомими прикладами інформаційних систем, що побудовані за цією моделлю, є Dropbox, Google Drive, Facebook, Twitter.
Розробляєма система складається з трьох основних компонентів: клієнтської частини, серверної частини та бази даних.
Клієнтська частина реалізована у вигляді веб-застосунку на основі фреймворку Angular та мобільного додатку, що взаємодіють із сервером через REST API. Вона забезпечує інтерфейс для користувачів, де вони можуть здійснювати авторизацію, додавати або редагувати продукти, переглядати інформацію про холодильники, моніторити стан продуктів, отримувати сповіщення та генерувати звіти. 
Серверна частина побудована на основі Node.js з використанням фреймворку Express. Вона відповідає за обробку запитів від клієнтської частини, управління бізнес-логікою, взаємодію з базою даних та забезпечення безпеки даних користувачів. Серверна частина реалізує REST API, яке дозволяє здійснювати CRUD-операції (Create, Read, Update, Delete) для основних сутностей, таких як користувачі, продукти, холодильники та сенсори. Також сервер забезпечує управління сесіями користувачів через механізм JWT (JSON Web Token), що гарантує захищений доступ до ресурсів. Окрім цього, серверна частина обробляє дані з IoT-сенсорів у реальному часі, що дозволяє відстежувати умови зберігання продуктів і вчасно реагувати на зміни параметрів, таких як температура або вологість.
База даних реалізована на основі реляційної системи управління базами даних MySQL. Вона використовується для зберігання інформації про користувачів, холодильники, продукти, дані сенсорів, сповіщення та налаштування системи. Зв'язок між серверною частиною та базою даних здійснюється через ORM (Object-Relational Mapping) Sequelize.
Перевагами цієї архітектури є модульність, висока масштабованість, легкість у підтримці та тестуванні компонентів. Клієнтська частина та сервер можуть розвиватися незалежно один від одного, що корисно під час оновлення функціоналу. Недоліками можуть бути потенційна затримка у мережевих запитах, залежність від стабільності інтернет-з'єднання та необхідність додаткової оптимізації для роботи з великими обсягами даних.

3.2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Діаграма розгортання відображає фізичне розташування компонентів програмної системи та шляхи зв'язку між ними. Вона демонструє, як програмні модулі взаємодіють між собою на рівні серверів, клієнтів та IoT-пристроїв. Було створено діаграму розгортання, що представлена на рисунку 1 в додатку Б.
Програмна система побудована за клієнт-серверною архітектурою, де основними вузлами є Clients, Server та IoT Sensors. Clients включає в себе веб-застосунок (Web Client) та мобільний додаток (Mobile Client), які взаємодіють із сервером за допомогою протоколів HTTP/HTTPS. Це забезпечує користувачам можливість взаємодіяти з даними у реальному часі, виконувати CRUD-операції та отримувати інформацію про стан продуктів. Server містить два основних компоненти: Backend Server та Database 
Server. Backend Server — це серверна частина, реалізована на Node.js з використанням фреймворку Express. Вона обробляє запити клієнтів, взаємодіє з базою даних та отримує дані від IoT-пристроїв. Database Server — реляційна база даних MySQL, що використовується для зберігання інформації про користувачів, холодильники, продукти, дані сенсорів та сповіщення. 
IoT Sensors включає Temperature Sensor для збору даних про температуру у холодильнику, Humidity Sensor для моніторингу рівня вологості та RFID Reader для ідентифікації продуктів, що зберігаються у холодильнику. Ці сенсори надсилають дані до серверної частини через HTTP-запити, де інформація обробляється та зберігається у базі даних.
Для комунікації між компонентами використовується HTTP/HTTPS — для передачі даних між клієнтами і сервером, та TCP/IP — для забезпечення зв'язку між Backend Server і Database Server. 

1.3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

Серверна частина програмної системи побудована на основі платформи Node.js з використанням фреймворку Express. Архітектура серверної частини реалізована за модульним принципом, що включає поділ на контролери, репозиторії, маршрути, бізнес-логіку та проміжне ПЗ (middlewares).
Контролери відповідають за обробку запитів, що надходять від клієнтів, і виклик відповідних методів із репозиторіїв. Кожен контролер відповідає за конкретну сутність або функціональність системи. Серед основних контролерів можна виділити: управління користувачами (реєстрація, авторизація, оновлення даних, видалення), CRUD-операції для холодильників, управління підключеними сенсорами, додавання, редагування та видалення продуктів у холодильнику, обробка даних з сенсорів та збереження історії, створення та відправка сповіщень, авторизація користувачів за допомогою JWT-токенів, управління адміністративними функціями та налаштуваннями доступу, генерація звітів для користувачів, управління системними налаштуваннями, управління зонами зберігання у холодильниках.
Репозиторії містять логіку доступу до бази даних MySQL з використанням ORM Sequelize. Вони забезпечують CRUD-операції для кожної сутності, що включає управління даними користувачів, холодильників, сенсорів, продуктів, обробку історії даних сенсорів та роботу зі сповіщеннями.
Маршрутизація запитів здійснюється через окремі файли маршрутів, де визначено шляхи доступу до API для кожної сутності. Кожен запит, що надходить до системи, перенаправляється на відповідний контролер, який, у свою чергу, взаємодіє з репозиторієм та базою даних. Основні маршрути включають управління користувачами, холодильниками, сенсорами, продуктами, даними сенсорів, сповіщеннями, авторизацією, адміністративними функціями, налаштуваннями та зонами зберігання.
Бізнес-логіка серверної частини реалізована у вигляді окремих модулів, що відповідають за обробку даних, аналітику та сповіщення. Основними процесами є розрахунок рекомендованої дати споживання продуктів, генерація сповіщень при завершенні терміну придатності або наближенні до цього, аналіз умов зберігання продуктів, генерація звітів для користувачів, обробка аномальних даних із сенсорів та відправка сповіщень користувачам.
Проміжне ПЗ реалізує механізми асинхронної обробки запитів, перевірку авторизації через JWT-токени та верифікацію ролей користувачів. Це підвищує рівень безпеки доступу до ресурсів і дозволяє легко інтегрувати нові перевірки без змін основного коду.
Підключення до бази даних здійснюється через файл db.js, який містить параметри доступу до MySQL та ініціалізацію Sequelize. Усі операції з даними виконуються асинхронно, що підвищує продуктивність обробки запитів. Дані зберігаються у реляційній базі даних MySQL, яка забезпечує цілісність і захищеність інформації.
Архітектура серверної частини побудована з урахуванням принципів модульності, що дозволяє масштабуватися і гнучко розширяти функціонал. Взаємодія з базою даних здійснюється через ORM Sequelize, щоб швидко реалізовувати CRUD-операції та обробляти дані з IoT-сенсорів у реальному часі. Реалізація проміжного ПЗ підвищує безпеку та знижує ризики помилок під час виконання запитів.

1.4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Діаграма прецедентів відображає взаємодію основних акторів із системою, демонструючи основні функціональні можливості програмної системи для контролю свіжості продуктів у холодильнику. Було створено діаграму прецедентів, що представлена на рисунку 2 в додатку Б.
Побудована діаграма включає п'ять основних акторів: Користувач, Глобальний адміністратор, Адміністратор бізнес-логіки, Адміністратор обслуговування, Адміністратор інфраструктури, а також зовнішній об'єкт IoT Пристрій, який надсилає дані до серверної частини системи.
Користувач має доступ до таких функцій, як авторизація, додавання продукту, редагування продукту, перегляд холодильників та отримання сповіщень. Ці дії забезпечують можливість управління вмістом холодильника, моніторинг термінів придатності продуктів та отримання сповіщень у разі критичних умов зберігання.
Глобальний адміністратор володіє повним набором прав на управління всіма аспектами системи. Йому доступні операції з управління користувачами, продуктами, холодильниками, а також адміністрування налаштувань системи. Окрім цього, глобальний адміністратор має можливість здійснювати моніторинг сенсорів, API, керувати розгортанням системи та резервним копіюванням.
Адміністратор бізнес-логіки має доступ до адміністрування користувачів, керування налаштуваннями та встановлення правил сповіщень. Це дозволяє йому контролювати доступ користувачів до системи, налаштовувати правила зберігання продуктів та регулювати критичні значення для сенсорів.
Адміністратор обслуговування займається моніторингом підключених сенсорів та станом API. Він також відповідає за обробку помилок, пов'язаних з підключенням та передачею даних від IoT-пристроїв.
Адміністратор інфраструктури має доступ до операцій, пов'язаних з резервним копіюванням та управлінням розгортанням системи. Він забезпечує стабільність роботи серверної частини, а також збереження і відновлення даних у випадку аварійних ситуацій.
IoT Пристрій представляє фізичні сенсори, які надсилають інформацію про температуру, вологість та RFID-мітки продуктів. Ці дані передаються до серверної частини, де обробляються та зберігаються для подальшого аналізу та відображення у клієнтських додатках.
Для кожного прецеденту вказані зв'язки з відповідними акторами, що вказує на розподіл прав доступу та взаємодії із системою. Діаграма допомагає відслідковувати, які операції доступні кожному типу користувача, чітко розмежувати ролі та функціональні можливості у системі. 

1.5 ПОБУДОВА ER-ДІАГРАМИ

ER-діаграма відображає структуру бази даних, включаючи сутності, атрибути, ключі та зв’язки між таблицями. Було створено ER-діаграму програмної системи для контролю свіжості продуктів у холодильнику, що представлена на рисунку 3 в додатку В. 
Щодо таблиць бази даних, то перша з них Users — зберігає інформацію про користувачів системи, включаючи їх імена, електронну пошту, пароль, роль у системі, а також час створення та оновлення запису. Вона має зв'язок 1:N з таблицею UserTokens (кожен користувач може мати декілька токенів авторизації), зв'язок 1:N з таблицею Notifications (один користувач може отримувати декілька сповіщень) та зв'язок 1:N з таблицею Refrigerators (один користувач може володіти кількома холодильниками).
UserTokens — ця таблиця зберігає інформацію про токени авторизації, які використовуються для доступу до системи. Вона містить ідентифікатор токена, ідентифікатор користувача, якому цей токен належить, час створення токена та час його закінчення. Зв'язок із таблицею Users є 1:N — один користувач може мати кілька токенів.
Notifications — містить інформацію про сповіщення, що надсилаються користувачам у випадку певних подій: закінчення терміну придатності продукту, перевищення допустимої температури або вологості тощо. Вона має зв'язок 1:N з таблицею Users (один користувач може мати кілька сповіщень) та N:1 з таблицею SensorData (одне сповіщення може стосуватися одного запису з даних сенсора).
Refrigerators — таблиця зберігає інформацію про холодильники, що належать користувачам. Кожен холодильник має унікальний ідентифікатор, посилання на власника, назву та локацію. Вона має зв'язок 1:N з таблицею Products (один холодильник може містити декілька продуктів), зв'язок 1:N з таблицею Zones (один холодильник може бути поділений на кілька зон) та зв'язок 1:N з таблицею Sensors (один холодильник може мати декілька сенсорів).
Products — зберігає дані про продукти, що розміщені в холодильниках. У ній міститься інформація про назву продукту, категорію, RFID-мітку, дату додавання та термін придатності. Таблиця має зв'язок 1:N з Refrigerators, оскільки один холодильник може мати багато продуктів.
Zones — представляє окремі логічні зони в межах одного холодильника. Це можуть бути різні відділення, наприклад, морозильна камера або овочевий відділ. Вона має зв'язок 1:N з таблицею Refrigerators.
Sensors — таблиця містить дані про сенсори, що підключені до холодильників. Сенсори можуть бути трьох типів: температурні, вологості та RFID. Вона має зв'язок 1:N з таблицею Refrigerators, оскільки один холодильник може мати декілька сенсорів. Також є зв'язок 1:N з SensorData, де зберігаються всі зчитані показники, і зв'язок 1:N з SensorThresholds, де налаштовані порогові значення.
SensorData — зберігає всі дані, які сенсори фіксують під час роботи: температуру, вологість та RFID-зчитування. Кожен запис містить час зчитування та показники. Вона має зв'язок 1:N з таблицею Sensors, а також зв'язок з Products, оскільки певні показники можуть бути прив'язані до продукту.
SensorThresholds — таблиця містить порогові значення для сенсорів, які визначають допустимі межі температури, вологості або інших показників. Вона має зв'язок 1:N з Sensors, оскільки один сенсор може мати декілька порогових значень.
Окрім основних сутностей, у базі даних програмної системи реалізовані конфігураційні таблиці: Settings, AlgorithmSettings, ReportSettings та SystemConfigurations. Вони виконують роль зберігання глобальних налаштувань та параметрів, необхідних для коректної роботи серверної частини та обчислювальних процесів. Дані з цих таблиць не залежать від CRUD-операцій основних користувачів, оскільки їхні значення переважно встановлюються під час ініціалізації системи або при зміні глобальних параметрів адміністратором.
Settings — ця таблиця зберігає глобальні налаштування системи, такі як мінімальні та максимальні значення температури та вологості. Вона не має прямих зовнішніх зв'язків, оскільки використовується для зчитування під час ініціалізації серверної частини.
AlgorithmSettings — містить конфігураційні параметри для обчислювальних алгоритмів у програмній системі. Вона використовується серверною частиною під час обробки даних, але не має прямих зв'язків з іншими таблицями.
ReportSettings — зберігає інформацію про частоту генерації звітів та останній час їх створення. Так само, як і Settings, ця таблиця не має зовнішніх зв'язків у базі даних.
SystemConfigurations — таблиця містить глобальні налаштування для всієї системи, які впливають на її роботу. Вона також не підключена до інших таблиць, але використовується під час старту серверної частини для налаштування параметрів.

1.6 СПЕЦИФІКАЦІЯ REST

Для забезпечення взаємодії між клієнтською та серверною частинами програмної системи було розроблено REST API, яке реалізує повний набір CRUD-операцій для основних сутностей: Users, Refrigerators, Products, Sensors, SensorData та Notifications. API підтримує стандартні HTTP-методи (GET, POST, PUT, PATCH, DELETE), забезпечуючи управління даними, моніторинг показників сенсорів у реальному часі та отримання сповіщень про критичні події. Окрім CRUD-операцій, API підтримує фільтрацію, сортування даних та авторизацію на основі JWT (JSON Web Token). Специфікація методів та маршрутів API детально описана в додатку А.
Під час виконання цієї лабораторної роботи було виконано розширення REST API: оновлено маршрути для основних сутностей, розширено CRUD-операції та забезпечено можливість управління даними для різних рівнів доступу (GlobalAdmin, ServiceAdmin, BusinessLogicAdmin та User). Було реалізовано повне логування адміністративних дій у таблиці AdminLogs, що дозволяє відстежувати додавання, редагування, видалення об'єктів, зміни в налаштуваннях сенсорів, алгоритмів та конфігурацій. Додано підтримку REST-запитів для управління холодильниками, продуктами, сенсорами, їхніми пороговими значеннями, моніторингом IoT-пристроїв та відновленням бази даних із резервних копій. Розширені маршрути для користувачів дозволяють редагувати профілі, отримувати звіти та керувати доступами. Для підвищення безпеки і контролю доступу були оновлені Middleware-обробники та маршрутизація, що забезпечує чіткий розподіл прав доступу відповідно до ролей користувачів. 

1.7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Діаграма компонентів відображає основні логічні елементи програмної системи, їхні зв'язки та взаємодію один з одним. Було створено діаграму компонентів, що представлена на рисунку 5 у додатку Б. Архітектура серверної частини побудована за багатошаровою моделлю, яка включає в себе чотири основні рівні: Presentation Layer, Logic Layer, Data Access Layer (DAL) та Configuration Management. 
Presentation Layer представлений компонентом API Gateway, який відповідає за маршрутизацію HTTP-запитів від клієнтських додатків (веб- та мобільних). Саме тут обробляються основні CRUD-операції: створення, отримання, оновлення та видалення даних. API Gateway виступає своєрідним шлюзом між зовнішніми клієнтами та внутрішньою бізнес-логікою системи. Запити, отримані API Gateway, перенаправляються до відповідних компонентів у Logic Layer.
Logic Layer складається з п'яти основних компонентів, кожен з яких відповідає за окрему частину бізнес-логіки. User Management забезпечує керування користувачами системи: створення облікових записів, авторизація, зміна даних користувачів. Він взаємодіє з Data Access Layer для отримання та збереження інформації у базу даних. Refrigerator Management відповідає за управління холодильниками, включаючи додавання, оновлення та видалення даних про холодильники. Він підключається до DAL для доступу до реляційної бази даних. Product Management забезпечує роботу з продуктами, що зберігаються в холодильниках: додавання нових продуктів, редагування інформації, контроль строків придатності. Sensor Management відповідає за моніторинг сенсорів, зчитування даних про температуру, вологість та RFID-мітки, а також управління підключеннями сенсорів до холодильників. Notification Service керує сповіщеннями для користувачів про критичні події, зокрема, закінчення терміну придатності продуктів, перевищення допустимої температури або вологості, збої в роботі сенсорів. Кожен з компонентів у Logic Layer підключений до Data Access Layer (DAL) для доступу до бази даних та до Configuration Management для отримання основних налаштувань.
Data Access Layer (DAL) забезпечує взаємодію бізнес-логіки з базою даних. Він реалізований у вигляді репозиторіїв для кожної сутності: UserRepository, RefrigeratorRepository, ProductRepository, SensorRepository, NotificationRepository. Всі CRUD-операції, пов'язані зі зберіганням та отриманням даних, реалізовані саме в цьому шарі. DAL також відповідає за оптимізацію запитів до бази даних, кешування результатів та обробку транзакцій.
Configuration Management забезпечує управління конфігураційними налаштуваннями програмної системи. Звідси зчитуються параметри підключення до бази даних, API-ключі, конфігурації сенсорів та основні налаштування безпеки. Він підключений до API Gateway та компонентів бізнес-логіки для зчитування та оновлення конфігурацій у реальному часі.
API Gateway викликає методи кожного з компонентів Logic Layer: CRUD-операції з користувачами, холодильниками, продуктами, сенсорами та сповіщеннями. Взаємодія здійснюється через стандартні REST-запити (GET, POST, PUT, DELETE). Компоненти бізнес-логіки (User Management, Refrigerator Management, Product Management, Sensor Management, Notification Service) звертаються до Data Access Layer (DAL) для отримання та зміни даних у базі. Configuration Management підключений до всіх компонентів для надання актуальних конфігурацій під час виконання бізнес-логіки. Data Access Layer (DAL) безпосередньо працює з базою даних, виконуючи запити на створення, отримання, оновлення та видалення даних.
 
4 ВИСНОВКИ
У результаті виконання лабораторної роботи було розроблено серверну частину програмної системи на основі клієнт-серверної архітектури з використанням Node.js та Express. Реалізовано CRUD-операції для основних сутностей (Users, Refrigerators, Products, Sensors, Notifications, Zones), забезпечено взаємодію з реляційною базою даних MySQL через ORM Sequelize. Впроваджено механізм обробки даних з IoT-сенсорів у реальному часі, що дозволяє відстежувати температуру, вологість та ідентифікацію продуктів через RFID. Для забезпечення доступу користувачів реалізовано JWT-авторизацію та управління ролями.
Система підтримує багаторівневе адміністрування, включаючи управління конфігураціями, резервне копіювання та відновлення даних. Розроблено REST API для забезпечення взаємодії між компонентами, виконано тестування основних функцій та побудовано UML-діаграми для опису архітектури.

ДОДАТОК А
Специфікація REST
Перелік реалізованих REST API методів:
1)	GET /users — отримати список усіх користувачів; 
2)	GET /users/:id — отримати дані користувача за його ID; 
3)	POST /users — створити нового користувача; 
4)	PUT /users/:id — оновити інформацію про користувача; 
5)	DELETE /users/:id — видалити користувача; 
6)	GET /refrigerators — отримати список усіх холодильників; 
7)	GET /refrigerators/:id — отримати інформацію про холодильник за його ID; 
8)	POST /refrigerators — створити новий холодильник; 
9)	PUT /refrigerators/:id — оновити дані про холодильник;
10)	DELETE /refrigerators/:id — видалити холодильник; 
11)	GET /refrigerators/user/:userId — отримати холодильники, які належать конкретному користувачу; 
12)	GET /refrigerators/location/:location — отримати холодильники за локацією; 
13)	GET /refrigerators/:id/last-update — отримати дату останнього оновлення холодильника; 
14)	GET /products — отримати список усіх продуктів; 
15)	GET /products/:id — отримати інформацію про продукт за його ID; 
16)	POST /products — додати новий продукт; 
17)	PUT /products/:id — оновити дані продукту; 
18)	DELETE /products/:id — видалити продукт; 
19)	GET /products/refrigerator/:refrigeratorId — отримати продукти, що знаходяться в певному холодильнику; 
20)	GET /products/category/:category — отримати продукти за категорією; 
21)	GET /sensors — отримати список усіх сенсорів; 
22)	GET /sensors/:id — отримати інформацію про сенсор за його ID; 
23)	POST /sensors — додати новий сенсор; 
24)	PUT /sensors/:id — оновити дані сенсора; 
25)	DELETE /sensors/:id — видалити сенсор; 
26)	GET /sensors/refrigerator/:refrigeratorId — отримати сенсори для конкретного холодильника; 
27)	PATCH /sensors/:id/status — оновити статус сенсора (Active/Inactive); 
28)	GET /sensors/type/:type — отримати сенсори за типом (Temperature, Humidity, RFID); 
29)	GET /sensor-data — отримати список усіх показників сенсорів; 
30)	GET /sensor-data/:id — отримати дані сенсора за його ID; 
31)	POST /sensor-data — додати новий запис показників; 
32)	PUT /sensor-data/:id — оновити дані сенсора; 
33)	DELETE /sensor-data/:id — видалити дані сенсора; 
34)	GET /sensor-data/sensor/:sensorId — отримати всі дані для конкретного сенсора; 
35)	GET /sensor-data/product/:productId — отримати дані для продукту, відслідкованого сенсором; 
36)	GET /sensor-data/date — отримати дані за датою; 
37)	GET /notifications — отримати список усіх сповіщень; 
38)	GET /notifications/:id — отримати інформацію про сповіщення за його ID; 
39)	POST /notifications — додати нове сповіщення; 
40)	PATCH /notifications/:id/status — оновити статус сповіщення (New/Read); 
41)	DELETE /notifications/:id — видалити сповіщення; 
42)	GET /notifications/user/:userId — отримати сповіщення, пов’язані з конкретним користувачем;
43)	GET /admin/db/performance — моніторинг процесів бази даних;
44)	POST /admin/db/backup — створення резервної копії бази даних;
45)	POST /admin/db/restore — відновлення бази даних з резервної копії;
46)	POST /admin/db/migrate — міграція бази даних;
47)	POST /admin/db/access — управління доступами до бази даних;
48)	GET /admin/configurations — отримання списку конфігурацій;
49)	PUT /admin/configurations — оновлення конфігурації;
50)	GET /admin/general-report — генерація загального звіту;
51)	GET /admin/api-status — перевірка статусу API;
52)	GET /admin/notification-rules — отримання всіх правил сповіщень;
53)	POST /admin/notification-rules — створення нового правила сповіщень;
54)	PUT /admin/notification-rules/:id — оновлення правила сповіщень;
55)	DELETE /admin/notification-rules/:id — видалення правила сповіщень.
 
Додаток Б 
Графічні матеріали
 
Рисунок Б.1 - ER-діаграма даних
 
Рисунок Б.2 — Структура бази даних 
 
Рисунок Б.3 – UML-діаграма прецедентів
 
Рисунок Б.4 – Діаграма компонентів програмної системи

Додаток В 
Програмний код

В.1 Математична обробка прикладних даних
GitHub репозиторій: https://github.com/NureKalenykVira/apz-pzpi-22-6-kalenyk-vira.
	
1.	const calculateDaysLeft = (expiryDate) => {
2.	    const now = new Date();
3.	    const expiry = new Date(expiryDate);
4.	    const timeDifference = expiry.getTime() - now.getTime();
5.	    const daysLeft = Math.ceil(timeDifference / (1000 * 3600 * 24));
6.	    return daysLeft > 0 ? daysLeft : 0;
7.	};
8.	const daysRemaining = calculateDaysLeft('2025-06-30');
9.	console.log(`Залишилось днів до закінчення терміну придатності: ${daysRemaining}`); 

В.2 Адміністрування бізнес-логіки системи (Генерація звітів)
GitHub репозиторій: https://github.com/NureKalenykVira/apz-pzpi-22-6-kalenyk-vira.

1.	const generateGeneralReport = async (req, res) => {
2.	    try {
3.	        const refrigerators = await db.query('SELECT * FROM refrigerators');
4.	        const products = await db.query('SELECT * FROM products');
5.	        
6.	        const report = {
7.	            totalRefrigerators: refrigerators.length,
8.	            totalProducts: products.length,
9.	            lastUpdated: new Date().toISOString()
10.	        };
11.	
12.	        res.status(200).json(report);
13.	    } catch (error) {
14.	        console.error('Помилка під час генерації звіту:', error);
15.	        res.status(500).json({ message: 'Помилка під час генерації звіту.' });
16.	    }
17.	};

В.3 Резервне копіювання користувацьких даних
GitHub репозиторій: https://github.com/NureKalenykVira/apz-pzpi-22-6-kalenyk-vira.

1.	const backupDatabase = async (req, res) => {
2.	    try {
3.	        console.log("Створення резервної копії бази даних...");
4.	        await db.query('BACKUP DATABASE fridge_system TO DISK = "backup_path.bak"');
5.	        res.status(200).json({ message: 'Резервне копіювання виконано успішно.' });
6.	    } catch (error) {
7.	        console.error('Помилка під час резервного копіювання:', error);
8.	        res.status(500).json({ message: 'Помилка під час резервного копіювання.' });
9.	    }
10.	};

В.4 Відновлення бази даних
GitHub репозиторій: https://github.com/NureKalenykVira/apz-pzpi-22-6-kalenyk-vira.
	
1.	const restoreDatabase = async (req, res) => {
2.	    try {
3.	        console.log("Відновлення бази даних...");
4.	        await db.query('RESTORE DATABASE fridge_system FROM DISK = "backup_path.bak"');
5.	        res.status(200).json({ message: 'Відновлення бази даних завершено успішно.' });
6.	    } catch (error) {
7.	        console.error('Помилка під час відновлення:', error);
8.	        res.status(500).json({ message: 'Помилка під час відновлення.' });
9.	    }
10.	};

В.5 Міграція бази даних
GitHub репозиторій: https://github.com/NureKalenykVira/apz-pzpi-22-6-kalenyk-vira.

1.	const migrateDatabase = async (req, res) => {
2.	    try {
3.	        console.log("Запуск міграції бази даних...");
4.	        await db.query('RUN MIGRATIONS');
5.	        res.status(200).json({ message: 'Міграція бази даних завершена успішно.' });
6.	    } catch (error) {
7.	        console.error('Помилка під час міграції бази даних:', error);
8.	        res.status(500).json({ message: 'Помилка під час міграції бази даних.' });
9.	    }
10.	};

В.6 Адміністрування доступу до бази даних
GitHub репозиторій: https://github.com/NureKalenykVira/apz-pzpi-22-6-kalenyk-vira.

1.	const manageDatabaseAccess = async (req, res) => {
2.	    const { userId, accessLevel } = req.body;
3.	    try {
4.	        console.log(`Зміна рівня доступу для користувача ${userId} на ${accessLevel}...`);
5.	        await db.query(`UPDATE users SET role = ? WHERE id = ?`, [accessLevel, userId]);
6.	        res.status(200).json({ message: `Рівень доступу для користувача ${userId} успішно змінено.` });
7.	    } catch (error) {
8.	        console.error('Помилка при зміні рівня доступу:', error);
9.	        res.status(500).json({ message: 'Помилка при зміні рівня доступу.' });
10.	    }
11.	};	

Додаток Г
Посилання на відеозапис доповіді та текст хронологічного опису доповіді
Відеозапис доповіді на YouTube: https://youtu.be/I2KxBqqqNeg.
Хронологічний опис доповіді:
1. 00:00 - Привітання; 
2. 00:19 - Опис звіту до лабораторної роботи 2; 
3. 01:08 – Огляд створених діаграм; 
4. 02:37 – Опис підключення бази даних;
5. 02:48 – Опис архітектури серверної частини;
6. 03:53 – Опис реалізованих раніше CRUD-операцій;
7. 04:15 – Опис змін, що були внесені в код серверної частини при виконанні цієї лабораторної роботи;
8. 05:24 – Тестування створених запитів;
9. 12:20 – Висновки.

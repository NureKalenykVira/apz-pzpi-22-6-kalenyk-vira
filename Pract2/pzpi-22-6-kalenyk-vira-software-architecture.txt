МІНІСТЕРСТВО ОСВІТИ I НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ



Кафедра програмної інженерії





ЗВІТ
до практичної роботи № 2
з дисципліни «Архітектура програмного забезпечення»
на тему «Архітектура програмної системи Netflix»





Виконала:                                                     	Перевірив:
ст. гр. ПЗПІ-22-6,                                           	 	ст. викл. каф. ПІ,
Каленик Віра Олександрівна					                            Сокорчук Ігор Петрович






Харків 2025
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	13.04.2025	0.1	Оформлено титульну сторінку, створено розділ «Завдання»
2	14.04.2025	0.2	Створено розділ «Опис виконаної роботи», додатки Б та В, написано розділ «Висновки»
3	14.04.2025	0.3	Додано додаток А, виправлено оформлення (додано колонтитули, налаштовано міжрядкові інтервали, тощо)

 
2 ЗАВДАННЯ
Завдання на практичне заняття 2:
1.	Підготувати доповідь на тему: «Архітектура програмної системи Netflix»;
2.	Створити та оформити слайди презентації доповіді;
3.	Створити та опублікувати на YouTube відеозапис доповіді;
4.	Оформити та завантажити на dl.nure.ua звіт до виконаної роботи;
5.	Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main;
6.	Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань;
7.	Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract2 у репозиторії GitHub;
8.	Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ2.

 
3	ОПИС ВИКОНАНОЇ РОБОТИ
1.	Було обрано архітектуру програмної системи Netflix для аналізу. 
2.	Було досліджено основні етапи розвитку платформи, особливості її переходу від монолітної архітектури до мікросервісної хмарної структури.
3.	Було зібрано статистичні дані щодо кількості користувачів, масштабів інфраструктури та обсягів оброблюваних даних.
4.	Було проаналізовано призначення системи, технологічний стек і використання мов програмування для окремих компонентів.
5.	Було детально розглянуто організацію архітектури: механізми взаємодії мікросервісів, балансування навантаження, кешування даних, забезпечення відмовостійкості та роботу власної CDN-мережі Open Connect.
6.	Було описано підходи до масштабування, застосування хаос-інженерії та реалізацію відмовостійкості через механізми Hystrix і Chaos Monkey.
7.	Було вивчено рішення у сфері персоналізації контенту, машинного навчання та рекомендаційних систем, включно з використанням Metaflow, TensorFlow та A/B тестування.
8.	Було розглянуто моделі монетизації платформи, включно з передплатою та новими тарифами з рекламою.
9.	Було проведено порівняння архітектури Netflix з аналогічними рішеннями інших сервісів, таких як YouTube, Disney+ та HBO Max.
10.	Було підготовлено презентацію за темою роботи, яка містить теоретичну частину, схеми, узагальнення прикладів та висновки (див. додаток Б).


 
4	ВИСНОВКИ
У результаті виконання роботи було досліджено архітектуру програмної системи Netflix, її ключові компоненти та принципи взаємодії між мікросервісами. Було проаналізовано рішення щодо масштабування, забезпечення відмовостійкості, обробки даних і персоналізації контенту. У процесі виконання роботи було отримано уявлення про принципи побудови складних розподілених систем та особливості архітектурних рішень, спрямованих на забезпечення масштабованості, стійкості та якості обслуговування користувачів.



 
ДОДАТОК А
Посилання на відеозапис доповіді та текст хронологічного опису доповіді
	Відеозапис доповіді на YouTube: https://youtu.be/DJ4RX_aUsYs.
Хронологічний опис доповіді: 
1.	00:00 - Привітання; 
2.	00:10 – Зміст доповіді;
3.	00:26 – Вступ;
4.	01:11 – Історія розвитку;
5.	02:17 - Ключові показники;
6.	03:25 - Призначення системи;
7.	04:51 - Технологічна база та мови програмування;
8.	06:11 - Архітектурний стиль;
9.	10:10 - Взаємодія між сервісами; 
10.	12:20 - Робота з даними та зберігання; 
11.	14:01 - Масштабування та стійкість;
12.	15:37 - Рекомендації та штучний інтелект;
13.	16:58 - Монетизація та моделі підписки;
14.	18:19 - Порівняння з аналогами;
15.	19:43 - Висновки;
16.	20:23 - Список використаних джерел;
17.	20:32 - Завершення.

	
 
ДОДАТОК Б
Слайди презентації доповіді

 
Рисунок Б.1 – Титульний слайд
 
Рисунок Б.2 – Зміст презентації
 
Рисунок Б.3 – Вступ
 
Рисунок Б.4 – Історія розвитку архітектури Netflix
 
Рисунок Б.5 – Ключові показники масштабу роботи Netflix
 
Рисунок Б.6 – Призначення системи
 
Рисунок Б.7 – Технологічна база та мови програмування
 
Рисунок Б.8 – Архітектурний стиль Netflix
 
Рисунок Б.9 – Взаємодія між сервісами у архітектурі
 
Рисунок Б.10 – Організація роботи з даними та зберігання у Netflix
 
Рисунок Б.11 – Використання EVCache і передання подій перегляду у Kafka
 
Рисунок Б.12 – Масштабування системи та забезпечення стійкості у Netflix
 
Рисунок Б.13 – Реалізація відмовостійкості за допомогою Hystrix та Chaos Monkey
 
Рисунок Б.14 – Використання машинного навчання та рекомендаційних систем у Netflix
 
Рисунок Б.15 – Побудова ML-пайплайну в Metaflow і логіка рекомендацій за жанрами
 
Рисунок Б.16 – Моделі монетизації та підписки в архітектурі Netflix
 
Рисунок Б.17 – Порівняння архітектури Netflix з аналогами
 
Рисунок Б.18 – Висновки
 
Рисунок Б.19 – Список використаних джерел
 
Рисунок Б.20 – Завершальний слайд
 
ДОДАТОК В
Приклади коду
1.	# EVCache – кешування користувацького профілю
2.	@EVCache(key = "#userId", cacheName = "UserProfiles", ttl = 300)
3.	public UserProfile getUserProfile(String userId) {
4.	    return userRepository.findById(userId);
5.	}
6.	
7.	# Kafka – надсилання події перегляду
8.	@Autowired
9.	private KafkaTemplate<String, ViewEvent> kafkaTemplate;
10.	
11.	public void sendViewingEvent(ViewEvent event) {
12.	    kafkaTemplate.send("viewing-events", event);
13.	}
14.	
15.	# Hystrix – захист сервісу від збоїв залежностей
16.	@HystrixCommand(fallbackMethod = "getFallbackCatalog")
17.	public List<Movie> getCatalog(String userId) {
18.	    Rating[] ratings = restTemplate.getForObject("http://ratings-service/ratings/" + userId, Rating[].class);
19.	
20.	    return Arrays.stream(ratings)
21.	        .map(rating -> restTemplate.getForObject("http://movies-service/movies/" + rating.getMovieId(), Movie.class))
22.	        .collect(Collectors.toList());
23.	}
24.	
25.	public List<Movie> getFallbackCatalog(String userId) {
26.	    return List.of(new Movie("0", "Недоступно", "Сервіс тимчасово недоступний"));
27.	}
28.	
29.	# Chaos Monkey – конфігурація fault injection
30.	{
31.	  "chaosType": "TerminateInstance",
32.	  "targetGroup": "user-service",
33.	  "interval": "hourly",
34.	  "probability": 0.2
35.	}
36.	
37.	# Metaflow – приклад побудови ML pipeline
38.	from metaflow import FlowSpec, step
39.	
40.	class RecommendationFlow(FlowSpec):
41.	
42.	    @step
43.	    def start(self):
44.	        self.user_data = load_user_data()
45.	        self.next(self.train)
46.	
47.	    @step
48.	    def train(self):
49.	        self.model = train_model(self.user_data)
50.	        self.next(self.end)
51.	
52.	    @step
53.	    def end(self):
54.	        print("Модель збережено:", self.model)
55.	
56.	# Content-based recommendation – спрощена логіка рекомендацій
57.	def recommend(user_id):
58.	    history = get_watch_history(user_id)
59.	    top_genres = extract_top_genres(history)
60.	    unseen = get_unwatched_titles(user_id)
61.	    return filter_by_genres(unseen, top_genres)[:10]
